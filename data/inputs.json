{
  "vacancy": "Software Developer Trainee\n\nBasic Qualifications\n\n Enrolled in a BS/MS program in CS/EE/CE (or related).\n Strong Python skills and solid understanding of data structures and algorithms.\n Experience with Kubernetes or cloud-native observability (Prometheus/Grafana, tracing, log pipelines).\n Familiarity with LLMs/AI concepts: prompt design, function/tool calling, RAG basics, evaluation.\n Working knowledge of Linux and containers; ability to read logs and troubleshoot systems.\n Understanding of networking fundamentals.\n Clear communication, curiosity, and a bias for hands-on experimentation.\n agent frameworks (LangChain, LangGraph, CrewAI) or vector databases.\n Experience in fine tuning LLMs or other ML models.\n Experience in Kubernetes administration and life-cycle management.\n Go (Golang) proficiency is a plus.\n Interest in telecom/5G, CNFs, or large-scale distributed systems.",
  "user_bio": "John Doe Software Developer Trainee\nPython C/C++ Go Generative AI Agentic AI\njohndoe@gmail.com\nHelsinki, Finland\n\nProgramming Python (FastAPI), C/C++, Go (idiomatic, microservices).\nAI/LLMs Prompt Design, RAG, Deep Learning\nDevOps Docker, Kubernetes, Git, Linux, Shell Scripting.\nDatabases Chroma DB vector, PostgreSQL, Redis cash.",
  "github_profile": "Software Engineer - Generative AI & Agentic AI",
  "github_repos": [
    {
      "name": "2D-Game",
      "readme": "\n# 2D Game: So_long\n\n## Overview\n\nSo_long is a basic 2D game using MLX42 library. The goal is to collect all collectibles and reach the exit while avoiding obstacles. Movement and interaction are restricted to predefined map constraints.\n\n### Mandatory Features\n\n- Collect all collectibles before exiting.\n\n- Move with W, A, S, D or/and arrow keys/ZQSD.\n\n- Cannot move through walls.\n\n- Display move count in the terminal.\n\n\n### Graphics\n\n- Smooth window interactions (minimization, focus change).\n\n- ESC or window close button exits the game.\n\n### Map Rules / Validaion\n\n- Valid elements: Walls (1), Collectibles (C), Empty (0), Exit (E), Player (P).\n\n- Must be rectangular and enclosed by walls.\n\n- Must contain one exit, at least one collectible, and a player start.\n\n- Checks for a valid path.\n\n- Errors result in a clean exit.\n\n- \"Corner-Based Radar System\"\n\n## Corner-Based Radar System\n\nCorner-Based Radar System ensures accurate collision detection, prevents movement through walls, improves game physics by enforcing tile-based positioning.\n\nThe init_corners() function ensures precise movement detection by calculating tile-based corner positions:\n```c\nvoid init_corners(t_corner *corner, int next_x, int next_y)\n{\n    corner->tlx = next_x / TILE_SIZE;\n    corner->tly = next_y / TILE_SIZE;\n    corner->trx = (next_x + TILE_SIZE - 1) / TILE_SIZE;\n    corner->try = next_y / TILE_SIZE;\n    corner->blx = next_x / TILE_SIZE;\n    corner->bly = (next_y + TILE_SIZE - 1) / TILE_SIZE;\n    corner->brx = (next_x + TILE_SIZE - 1) / TILE_SIZE;\n    corner->bry = (next_y + TILE_SIZE - 1) / TILE_SIZE;\n}\n```\n\n## Installation & Execution\n```bash\ngit clone https://github.com/iliamunaev/2D-Game.git && cd 2D-Game\t# Clone the repo and change dir\n```\n```bash\nmake\t# Compile the game\n```\nChoos map from maps/ directory\n```bash\n./so_long maps/normal_map.ber  # Run the game\n```\nClean the game\n```bash\nmake clean    # Remove compiled files\nmake fclean   # Full cleanup\nmake re       # Recompile\n```\n## Memory leaks checkers\n```bash\nvalgrind --leak-check=full --track-origins=yes --suppressions=valgrind.supp ./so_long maps/map_correct.ber\t#with suppression file\n```\n```bash\nvalgrind --suppressions=valgrind.supp ./so_long maps/normal_map.ber\t#with suppression file\n```\n```bash\nvalgrind --leak-check=full --track-origins=yes ./so_long maps/normal_map.ber\t#without suppression file\n```\n### Game design: [Oksana Plieva](https://www.linkedin.com/in/oksana-plieva-a3838228b/)\n"
    },
    {
      "name": "ADC-Analog-Digital-Converter",
      "readme": "# ADC Analog-Digital Converter\r\n\r\nA command-line program that simulates an Analog-to-Digital Converter (ADC), converting analog voltage inputs to their digital binary representations based on configurable bit resolution and voltage reference ranges.\r\n\r\n## Table of Contents\r\n\r\n- [Features](#features)\r\n- [How It Works](#how-it-works)\r\n- [Installation](#installation)\r\n- [Usage](#usage)\r\n- [Examples](#examples)\r\n- [Testing](#testing)\r\n- [Project Structure](#project-structure)\r\n- [Technical Details](#technical-details)\r\n- [Dependencies](#dependencies)\r\n- [Contributing](#contributing)\r\n- [License](#license)\r\n\r\n## Features\r\n\r\n- **Configurable Bit Resolution**: Support for various ADC resolutions (4-bit, 8-bit, 12-bit, 16-bit, etc.)\r\n- **Flexible Voltage Ranges**: Customizable reference voltage ranges for different applications\r\n- **Input Validation**: Comprehensive validation of input parameters with helpful error messages\r\n- **Binary Output**: Clear binary representation of converted digital values\r\n- **Clamping Support**: Graceful handling of out-of-range input voltages\r\n- **Command-line Interface**: Simple and intuitive CLI for single conversions\r\n- **Comprehensive Testing**: Automated test suite with various scenarios\r\n\r\n## How It Works\r\n\r\nThe ADC converter simulates the real-world analog-to-digital conversion process:\r\n\r\n1. **Analog Input**: Accepts an analog voltage value within a specified range\r\n2. **Quantization**: Divides the voltage range into discrete steps based on bit resolution\r\n3. **Digital Conversion**: Maps the analog voltage to the nearest digital representation\r\n4. **Binary Output**: Displays the result as a binary string\r\n\r\n### Conversion Formula\r\n\r\n```\r\nADC_Resolution = (V_high - V_low) / (2^bits - 1)\r\nDigital_Output = round((V_input - V_low) / ADC_Resolution)\r\n```\r\n\r\nWhere:\r\n- `V_input`: Analog input voltage\r\n- `V_high`, `V_low`: Reference voltage range\r\n- `bits`: ADC bit resolution\r\n\r\n## Installation\r\n\r\n### Prerequisites\r\n\r\n- GCC compiler (or compatible C compiler)\r\n- Make build system\r\n- Git (for Libft dependency)\r\n\r\n### Build Instructions\r\n\r\n1. Clone the repository:\r\n```bash\r\ngit clone https://github.com/yourusername/ADC-Analog-Digital-Converter.git\r\ncd ADC-Analog-Digital-Converter\r\n```\r\n\r\n2. Build the project:\r\n```bash\r\nmake\r\n```\r\n\r\nThe build process will:\r\n- Automatically clone and build the Libft library dependency\r\n- Compile all source files with strict error checking (`-Wextra -Wall -Werror`)\r\n- Link the executable as `ADC`\r\n\r\n## Usage\r\n\r\n### Basic Syntax\r\n\r\n```bash\r\n./ADC <voltage_input> <bit_resolution> <voltage_low> <voltage_high>\r\n```\r\n\r\n### Parameters\r\n\r\n- `voltage_input`: Analog input voltage (integer, will be clamped if outside range)\r\n- `bit_resolution`: ADC bit resolution (positive integer, typically 4-32)\r\n- `voltage_low`: Lower bound of reference voltage range (double)\r\n- `voltage_high`: Upper bound of reference voltage range (double, must be > voltage_low)\r\n\r\n### Special Commands\r\n\r\n- `./ADC exit`: Gracefully terminate the program\r\n\r\n### Example Usage\r\n\r\n```bash\r\n# Convert 3.5V with 8-bit resolution in 0-5V range\r\n./ADC 3 8 0.0 5.0\r\n\r\n# Convert 2.1V with 12-bit resolution in 0-3.3V range\r\n./ADC 2 12 0.0 3.3\r\n\r\n# Exit the program\r\n./ADC exit\r\n```\r\n\r\n## Examples\r\n\r\n### Example 1: 8-bit ADC with 0-5V range\r\n```bash\r\n$ ./ADC 3 8 0 5\r\n00000011\r\n```\r\n\r\n**Explanation**: 3V input with 8-bit resolution in 0-5V range produces binary value 00000011 (decimal 3).\r\n\r\n### Example 2: 4-bit ADC with 0-5V range\r\n```bash\r\n$ ./ADC 5 4 0 5\r\n1111\r\n```\r\n\r\n**Explanation**: 5V input (maximum) with 4-bit resolution produces binary value 1111 (decimal 15).\r\n\r\n### Example 3: Input voltage clamping\r\n```bash\r\n$ ./ADC 7 8 0 5\r\nError: analog input value is outside the voltage range. It will be clamped\r\n11111111\r\n```\r\n\r\n**Explanation**: 7V input exceeds the 0-5V range and gets clamped to 5V (maximum), producing 11111111.\r\n\r\n## Testing\r\n\r\nRun the comprehensive test suite to verify functionality:\r\n\r\n```bash\r\n./tests/run_tests.sh\r\n```\r\n\r\nThe test suite includes:\r\n- Valid conversion scenarios with expected outputs\r\n- Invalid input validation (negative bit resolution, invalid voltage ranges)\r\n- Edge cases (minimum/maximum values, clamping scenarios)\r\n- Exit command functionality\r\n\r\n### Sample Test Output\r\n\r\n```\r\nRunning ADC Program Tests...\r\n----------------------------\r\nTest: ./ADC 3 8 0 5 -> \u2705 PASSED\r\nTest: ./ADC 6 8 0 10 -> \u2705 PASSED\r\nTest: ./ADC 0 4 0 5 -> \u2705 PASSED\r\nTest: ./ADC 5 4 0 5 -> \u2705 PASSED\r\nTest: ./ADC 10 16 0 100 -> \u2705 PASSED\r\nTest: ./ADC -3 8 0 5 (Invalid Input) -> \u2705 PASSED\r\nTest: ./ADC 3 -8 0 5 (Invalid Input) -> \u2705 PASSED\r\nTest: ./ADC 3 8 5 0 (Invalid Input) -> \u2705 PASSED\r\nTest: ./ADC 3 40 0 5 (Invalid Input) -> \u2705 PASSED\r\nTest: ./ADC exit -> \u2705 PASSED\r\n----------------------------\r\nTesting Complete.\r\n```\r\n\r\n## Project Structure\r\n\r\n```\r\nADC-Analog-Digital-Converter/\r\n\u251c\u2500\u2500 includes/\r\n\u2502   \u2514\u2500\u2500 converter.h          # Header file with function declarations\r\n\u251c\u2500\u2500 src/\r\n\u2502   \u251c\u2500\u2500 main.c               # Main entry point and argument parsing\r\n\u2502   \u251c\u2500\u2500 adc.c                # Core ADC conversion algorithm\r\n\u2502   \u251c\u2500\u2500 input_validation.c   # Input parameter validation\r\n\u2502   \u251c\u2500\u2500 utils.c              # Output formatting utilities\r\n\u2502   \u2514\u2500\u2500 *.o                  # Compiled object files\r\n\u251c\u2500\u2500 libft/                   # Libft library dependency (auto-cloned)\r\n\u251c\u2500\u2500 tests/\r\n\u2502   \u2514\u2500\u2500 run_tests.sh         # Comprehensive test suite\r\n\u251c\u2500\u2500 Makefile                 # Build configuration\r\n\u2514\u2500\u2500 README.md               # This documentation\r\n```\r\n\r\n## Technical Details\r\n\r\n### ADC Conversion Process\r\n\r\n1. **Resolution Calculation**: Determines voltage step size per digital unit\r\n2. **Quantization**: Maps analog voltage to nearest digital representation\r\n3. **Clamping**: Ensures output stays within valid digital range [0, 2^bits-1]\r\n4. **Binary Conversion**: Transforms decimal digital value to binary string\r\n\r\n### Bit Resolution Impact\r\n\r\n| Resolution | Digital Range | Voltage Resolution (0-5V) |\r\n|------------|---------------|---------------------------|\r\n| 4-bit     | 0-15         | 0.333V                   |\r\n| 8-bit     | 0-255        | 0.020V                   |\r\n| 12-bit    | 0-4095       | 0.001V                   |\r\n| 16-bit    | 0-65535      | 0.00008V                 |\r\n\r\n### Error Handling\r\n\r\nThe program handles various error conditions:\r\n- Insufficient arguments\r\n- Invalid bit resolution (\u2264 0)\r\n- Invalid voltage range (high \u2264 low)\r\n- Out-of-range input voltages (with clamping)\r\n\r\n## Dependencies\r\n\r\n- **Libft**: Custom C library providing string manipulation and I/O functions\r\n  - Automatically cloned from: `https://github.com/iliamunaev/libft-C-library`\r\n  - Provides: `ft_atoi`, `ft_strcmp`, `ft_putstr_fd`, etc.\r\n\r\n## Build Targets\r\n\r\n- `make` or `make all`: Build the executable\r\n- `make clean`: Remove object files\r\n- `make fclean`: Remove object files and executable\r\n- `make re`: Rebuild everything from scratch\r\n\r\n## Contributing\r\n\r\n1. Fork the repository\r\n2. Create a feature branch (`git checkout -b feature/amazing-feature`)\r\n3. Commit your changes (`git commit -m 'Add amazing feature'`)\r\n4. Push to the branch (`git push origin feature/amazing-feature`)\r\n5. Open a Pull Request\r\n\r\n## License\r\n\r\nThis project is licensed under the MIT License - see the LICENSE file for details.\r\n\r\n## Author\r\n\r\nCreated as part of a C programming curriculum focusing on embedded systems concepts and low-level programming.\r\n\r\n---\r\n\r\n**Note**: This is a simulation program for educational purposes. Real ADC converters involve hardware components and may have additional considerations like sampling rate, noise, and precision limitations.\r\n"
    },
    {
      "name": "chess-ai-classifier",
      "readme": "# Chess Piece Classifier\n\nA deep learning model for classifying chess pieces using computer vision. Built with FastAI and ConvNeXt Tiny architecture.\n\n## Overview\n\nThis project trains a convolutional neural network to identify six different chess pieces: Bishop, King, Knight, Pawn, Queen, and Rook. The model achieves high accuracy through transfer learning and data augmentation techniques.\n\n## Dataset\n\n- **Source**: Chessman Image Dataset from Kaggle\n- **Size**: 1,104 images total\n- **Classes**: 6 chess piece types\n- **Split**: 80% training, 20% validation\n\n## Model Architecture\n\n- **Base Model**: ConvNeXt Tiny (pretrained on ImageNet)\n- **Framework**: FastAI v2\n- **Input Size**: 320x320 pixels\n- **Data Augmentation**: Random cropping, rotation (\u00b110\u00b0), zoom (up to 10%), brightness/contrast adjustments\n- **Batch Size**: 64\n- **Training**: Fine-tuning for 5 epochs\n\n## Features\n\n- Automated data preprocessing and augmentation\n- Real-time inference with confidence scores\n- Interactive web interface using Gradio\n- Model export for deployment\n- Comprehensive evaluation metrics\n\n\n## Training\nRun the Jupyter notebook `chess_ai_notebook.ipynb` to:\n1. Download and prepare the dataset\n2. Train the ConvNeXt model\n3. Evaluate performance\n4. Export the trained model\n\n### Inference\n```python\nfrom fastai.vision.all import *\n\n# Load trained model\nlearn = load_learner('chessman_model.pkl')\n\n# Predict on new image\npred, pred_idx, probs = learn.predict('path/to/chess_piece.jpg')\nprint(f\"Prediction: {pred}\")\n```\n\n## Files\n\n- `chess_ai_notebook.ipynb` - Complete training and evaluation pipeline\n"
    }
  ]
}