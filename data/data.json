{
  "vacancy": "Software Developer Trainee Basic Qualifications Enrolled in a BS MS program in CS EE CE or related Strong Python skills and solid understanding of data structures and algorithms. Experience with Kubernetes or cloud-native observability Prometheus Grafana tracing log pipelines Familiarity with LLMs AI concepts prompt design function tool calling RAG basics evaluation. Working knowledge of Linux and containers ability to read logs and troubleshoot systems. Understanding of networking fundamentals. Clear communication curiosity and a bias for hands-on experimentation. agent frameworks LangChain LangGraph CrewAI or vector databases. Experience in fine tuning LLMs or other ML models. Experience in Kubernetes administration and life-cycle management. Go Golang proficiency is a plus. Interest in telecom 5G CNFs or large-scale distributed systems.",
  "user_bio": "Software Enginner Trainee Python C C++ Go Generative AI Agentic AI Helsinki Finland Programming Python FastAPI C C++ Go idiomatic microservices AI LLMs Prompt Design RAG Deep Learning fine-tuning models DevOps Docker Kubernetes Git Linux Shell Scripting. Databases Chroma DB vector PostgreSQL Redis cache.",
  "github_profile": "Software Engineer - Generative AI & Agentic AI",
  "github_repos": [
    {
      "name": "2D-Game",
      "readme": "2D Game So_long Overview So_long is a basic 2D game using MLX42 library. The goal is to collect all collectibles and reach the exit while avoiding obstacles. Movement and interaction are restricted to predefined map constraints. Mandatory Features - Collect all collectibles before exiting. - Move with W A S D or and arrow keys ZQSD. - Cannot move through walls. - Display move count in the terminal. Graphics - Smooth window interactions minimization focus change - ESC or window close button exits the game. Map Rules Validaion - Valid elements Walls 1 Collectibles C Empty 0 Exit E Player P - Must be rectangular and enclosed by walls. - Must contain one exit at least one collectible and a player start. - Checks for a valid path. - Errors result in a clean exit. - Corner-Based Radar System Corner-Based Radar System Corner-Based Radar System ensures accurate collision detection prevents movement through walls improves game physics by enforcing tile-based positioning. The init_corners function ensures precise movement detection by calculating tile-based corner positions c void init_corners t_corner corner int next_x int next_y corner- tlx next_x TILE_SIZE corner- tly next_y TILE_SIZE corner- trx next_x + TILE_SIZE - 1 TILE_SIZE corner- try next_y TILE_SIZE corner- blx next_x TILE_SIZE corner- bly next_y + TILE_SIZE - 1 TILE_SIZE corner- brx next_x + TILE_SIZE - 1 TILE_SIZE corner- bry next_y + TILE_SIZE - 1 TILE_SIZE Installation Execution bash git clone https github.com iliamunaev 2D-Game.git cd 2D-Game Clone the repo and change dir bash make Compile the game Choos map from maps directory bash so_long maps normal_map.ber Run the game Clean the game bash make clean Remove compiled files make fclean Full cleanup make re Recompile Memory leaks checkers bash valgrind --leak-check full --track-origins yes --suppressions valgrind.supp so_long maps map_correct.ber with suppression file bash valgrind --suppressions valgrind.supp so_long maps normal_map.ber with suppression file bash valgrind --leak-check full --track-origins yes so_long maps normal_map.ber without suppression file Game design Oksana Plieva https www.linkedin.com in oksana-plieva-a3838228b"
    },
    {
      "name": "ADC-Analog-Digital-Converter",
      "readme": "ADC Analog-Digital Converter A command-line program that simulates an Analog-to-Digital Converter ADC converting analog voltage inputs to their digital binary representations based on configurable bit resolution and voltage reference ranges. Table of Contents - Features features - How It Works how-it-works - Installation installation - Usage usage - Examples examples - Testing testing - Project Structure project-structure - Technical Details technical-details - Dependencies dependencies - Contributing contributing - License license Features - Configurable Bit Resolution Support for various ADC resolutions 4-bit 8-bit 12-bit 16-bit etc. - Flexible Voltage Ranges Customizable reference voltage ranges for different applications - Input Validation Comprehensive validation of input parameters with helpful error messages - Binary Output Clear binary representation of converted digital values - Clamping Support Graceful handling of out-of-range input voltages - Command-line Interface Simple and intuitive CLI for single conversions - Comprehensive Testing Automated test suite with various scenarios How It Works The ADC converter simulates the real-world analog-to-digital conversion process 1. Analog Input Accepts an analog voltage value within a specified range 2. Quantization Divides the voltage range into discrete steps based on bit resolution 3. Digital Conversion Maps the analog voltage to the nearest digital representation 4. Binary Output Displays the result as a binary string Conversion Formula ADC_Resolution V_high - V_low 2 bits - 1 Digital_Output round V_input - V_low ADC_Resolution Where - V_input Analog input voltage - V_high V_low Reference voltage range - bits ADC bit resolution Installation Prerequisites - GCC compiler or compatible C compiler - Make build system - Git for Libft dependency Build Instructions 1. Clone the repository bash git clone https github.com yourusername ADC-Analog-Digital-Converter.git cd ADC-Analog-Digital-Converter 2. Build the project bash make The build process will - Automatically clone and build the Libft library dependency - Compile all source files with strict error checking -Wextra -Wall -Werror - Link the executable as ADC Usage Basic Syntax bash ADC voltage_input bit_resolution voltage_low voltage_high Parameters - voltage_input Analog input voltage integer will be clamped if outside range - bit_resolution ADC bit resolution positive integer typically 4-32 - voltage_low Lower bound of reference voltage range double - voltage_high Upper bound of reference voltage range double must be voltage_low Special Commands - ADC exit Gracefully terminate the program Example Usage bash Convert 3.5V with 8-bit resolution in 0-5V range ADC 3 8 0.0 5.0 Convert 2.1V with 12-bit resolution in 0-3.3V range ADC 2 12 0.0 3.3 Exit the program ADC exit Examples Example 1 8-bit ADC with 0-5V range bash ADC 3 8 0 5 00000011 Explanation 3V input with 8-bit resolution in 0-5V range produces binary value 00000011 decimal 3 Example 2 4-bit ADC with 0-5V range bash ADC 5 4 0 5 1111 Explanation 5V input maximum with 4-bit resolution produces binary value 1111 decimal 15 Example 3 Input voltage clamping bash ADC 7 8 0 5 Error analog input value is outside the voltage range. It will be clamped 11111111 Explanation 7V input exceeds the 0-5V range and gets clamped to 5V maximum producing 11111111. Testing Run the comprehensive test suite to verify functionality bash tests run_tests.sh The test suite includes - Valid conversion scenarios with expected outputs - Invalid input validation negative bit resolution invalid voltage ranges - Edge cases minimum maximum values clamping scenarios - Exit command functionality Sample Test Output Running ADC Program Tests. ---------------------------- Test ADC 3 8 0 5 - PASSED Test ADC 6 8 0 10 - PASSED Test ADC 0 4 0 5 - PASSED Test ADC 5 4 0 5 - PASSED Test ADC 10 16 0 100 - PASSED Test ADC -3 8 0 5 Invalid Input - PASSED Test ADC 3 -8 0 5 Invalid Input - PASSED Test ADC 3 8 5 0 Invalid Input - PASSED Test ADC 3 40 0 5 Invalid Input - PASSED Test ADC exit - PASSED ---------------------------- Testing Complete. Project Structure ADC-Analog-Digital-Converter includes converter.h Header file with function declarations src main.c Main entry point and argument parsing adc.c Core ADC conversion algorithm input_validation.c Input parameter validation utils.c Output formatting utilities .o Compiled object files libft Libft library dependency auto-cloned tests run_tests.sh Comprehensive test suite Makefile Build configuration README.md This documentation Technical Details ADC Conversion Process 1. Resolution Calculation Determines voltage step size per digital unit 2. Quantization Maps analog voltage to nearest digital representation 3. Clamping Ensures output stays within valid digital range 0 2 bits-1 4. Binary Conversion Transforms decimal digital value to binary string Bit Resolution Impact Resolution Digital Range Voltage Resolution 0-5V ------------ --------------- --------------------------- 4-bit 0-15 0.333V 8-bit 0-255 0.020V 12-bit 0-4095 0.001V 16-bit 0-65535 0.00008V Error Handling The program handles various error conditions - Insufficient arguments - Invalid bit resolution 0 - Invalid voltage range high low - Out-of-range input voltages with clamping Dependencies - Libft Custom C library providing string manipulation and I O functions - Automatically cloned from https github.com iliamunaev libft-C-library - Provides ft_atoi ft_strcmp ft_putstr_fd etc. Build Targets - make or make all Build the executable - make clean Remove object files - make fclean Remove object files and executable - make re Rebuild everything from scratch Contributing 1. Fork the repository 2. Create a feature branch git checkout -b feature amazing-feature 3. Commit your changes git commit -m Add amazing feature 4. Push to the branch git push origin feature amazing-feature 5. Open a Pull Request License This project is licensed under the MIT License - see the LICENSE file for details. Author Created as part of a C programming curriculum focusing on embedded systems concepts and low-level programming. --- Note This is a simulation program for educational purposes. Real ADC converters involve hardware components and may have additional considerations like sampling rate noise and precision limitations."
    },
    {
      "name": "chess-ai-classifier",
      "readme": "Chess Piece Classifier A deep learning model for classifying chess pieces using computer vision. Built with FastAI and ConvNeXt Tiny architecture. Overview This project trains a convolutional neural network to identify six different chess pieces Bishop King Knight Pawn Queen and Rook. The model achieves high accuracy through transfer learning and data augmentation techniques. Dataset - Source Chessman Image Dataset from Kaggle - Size 1 104 images total - Classes 6 chess piece types - Split 80 training 20 validation Model Architecture - Base Model ConvNeXt Tiny pretrained on ImageNet - Framework FastAI v2 - Input Size 320x320 pixels - Data Augmentation Random cropping rotation 10 zoom up to 10 brightness contrast adjustments - Batch Size 64 - Training Fine-tuning for 5 epochs Features - Automated data preprocessing and augmentation - Real-time inference with confidence scores - Interactive web interface using Gradio - Model export for deployment - Comprehensive evaluation metrics Training Run the Jupyter notebook chess_ai_notebook.ipynb to 1. Download and prepare the dataset 2. Train the ConvNeXt model 3. Evaluate performance 4. Export the trained model Inference python from fastai.vision.all import Load trained model learn load_learner chessman_model.pkl Predict on new image pred pred_idx probs learn.predict path to chess_piece.jpg print f Prediction pred Files - chess_ai_notebook.ipynb - Complete training and evaluation pipeline"
    }
  ]
}